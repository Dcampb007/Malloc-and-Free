Linked List Style
Class definition of Node :
------------------------------------------
||      |PREVIOUS|NEXT   |NEXT |        ||
|| SIZE |NODE    |NODE   |FREE | ELEMENT||
||      |POINTER |POINTER|SPACE|        ||
------------------------------------------

static boolean flag = false #FIRST SBRK
static ptr* head = null # has not been intialized yet
static ptr* last = null
static int defaultsbrkvalue # this will have default value that can be updated if the number of total elements is known before the first call to malloc

malloc(number #ofbytestoadd){
    if(flag==false){
        load defaultsbrkvalue into a0
        syscall instruction 9 for sbrk

        Node new_node = create new node starting at address of v0
        new_node->size=defaultsbrkvalue
        new_node->prev_node_ptr=null #since it's the head
        new_node->next_node_ptr=null #since it's the only element
        new_node->next_free_space=defaultsbrkvalue-(16+#ofbytestoadd)
        new_node->element = 0 #initialize with all 0s
        ptr* head = new_node
        ptr* last = new_node
        set flag to true
        return new_node
    }
    else{
        Node node = head;
        while(node->next!=null){
            Node next_node=node->next;
            if(node->nextfreespace>=(16+#ofbytestoadd)){//if there is enough space between the end of the node and the start of the next one then
            Node new_node = location after node.
            last->next=new_node ## last->next=&node+16+node->size # the new node will be put after node
            new_node->previous=last
            new_node->next = null
            new_node->next_free_space=node->next_free_space - next_node->next_free_space
            node->next_free_space=null
            return new_node
            }
        }
        if(node->next==null){//ie if there is no space in that heap
            then we load word into a0
            syscall instruction 10 for sbrk
            end_size=calculate size from end of end pointer node to the start of the new returned ptr in v0
            end-> size = size //this is done to skip the space in between which is not accessible
            update the pointer metadata with the size = to #ofbytes to be added
            return the head of the new heap since that'll be the first available location
        }
    }
}

NOTE: I AM UNSURE HOW MUCH SPACE WE GET FROM USING THE SBRK syscall. Based on how much er get we'd backtrack from the size by the size for the meta data and
      make size null and next null UNTIL sbrk is called again.
      Apparently you put the number of bytes in a0.
